---
title: "Regions2.0 Tutorial"
author: "Amandine Gillet"
date: "24/01/2023"
output:
  html_document:
    toc: true
    theme: united
---

<style>
p.caption {
  font-size: 0.8em;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




## Package description

The `regions` package is built to computationally identify regions (morphological, functional, etc.) in serially homologous structures (such as the backbone).

The idea is to find "breakpoints" where variables differ along the serially homologous structure based on segmented linear regressions and use maximum-likelihood methods to identify the best model without *a priori* on the position of the breakpoint(s). 





```{r images, fig.show = "hold", out.width = "30%", fig.align = "default", fig.cap="regions allows to find breaks in serially homologous structures by fitting all possible break positions for a given number of breaks and then repeating the method on increasingly complex models.",echo=F}

knitr::include_graphics("images/Regions_image2.jpg")

knitr::include_graphics("images/Gif_segreg_1bp_25delay.gif")

knitr::include_graphics("images/Gif_segreg_50delay.gif")

```

<br>


The user needs to define a number of regions up to which they want the analysis to be run (e.g., up to 5 regions). The analysis will then start fitting models from the simplest (1 region, so 0 breakpoint) to the most complex (here, 5 regions, so 4 breakpoints). For each given number of regions, the analysis will fit all possible models (all possible breakpoint position) and will keep the best model (lowest residual sum of squares, RSS). It will then compare all the best models (the best model of each number of region) among them and will select the best one based on AIC and/or BIC.


*Methods and code are based on [Jones et al. (2018)](https://www.science.org/doi/abs/10.1126/science.aar3126) which was inspired by previous work from [Head & Polly (2015)](https://www.nature.com/articles/nature14042).*


*Note: this tutorial is based on Katrina's [tutorial for v.1](https://www.katrinaejones.com/_files/ugd/7af18e_1640f89aea8a432b9d8bf6ddf748e3ae.pdf) of regions package. V.2 of the package relies on some v.1 functions.*


The general concept of the package is still the same as v.1. However v.2 was re-written mostly to improve computational methods (reduced time and memory required) due to the challenge of working with cetaceans with high vertebral counts and number of regions. The v.2 also introduces a few new functions and plotting methods.




### B. Ordinating data

*Copied from Katrina's [tutorial for v.1](https://www.katrinaejones.com/_files/ugd/7af18e_1640f89aea8a432b9d8bf6ddf748e3ae.pdf)*

To incorporate a wide variety of data types, and potential missing data, you can use a distance-based data ordination, though the analysis should work equally well on PCA where data are appropriate. Principal coordinates analysis (PCO) is used to create axes which maximize the variation. The implementation employed in `svdPCO` uses a distance matrix generated by `cluster::daisy`. It differs from other implementations of PCO (e.g., based on `CMDscale`) as it uses a singular value decomposition (i.e., `svd`) instead of the more generalized `eigen`, thereby avoiding negative eigenvalues. 

Three types of distance metric can be used: euclidean, manhatten, or gower. Euclidean should only be used where all variables are similar (e.g., linear measures on the same scale), and is most similar to a PCA. Gower is good for combining different types of continuous data (e.g., angles and linear). Missing data is allowed, as long as there is some overlap in represented variables. For more information see `?(daisy)`.


```{r Run_pco}
pco.gower <- svdPCO(data_scaled,"gower")
PCOscores <- pco.gower$scores
PCOscores[,1:5]
```

Get variance & eigenvalues of each PCO axis:

```{r Get_variance}
variance <- round(pco.gower$eigen.val/sum(pco.gower$eigen.val)*100,5)
eig <- cbind(eigenvalues=round(pco.gower$eigen.val,5), variance)
rownames(eig) <- paste("PCO", 1:nrow(eig), sep=".")
dim(eig)
head(eig,15)
```


Now that we ran the region analysis we can see what is the minimum number of PCOs required to maximize the region score using the `PCOmaxAG` function. It returns the optimal number of PCOs calculated using AICc and BIC and also returns the respective region score obtained for each number of PCOs using AICc and BIC.


```{r}
PCOmaxAG(regiondata, nvert=nvert, cont=cont)
```


In this case the `regiondata` object was obtained using only the PCOs and `PCOmaxAG` returned 2 PCOs as the optimal number but it didn't test a higher number of PCOs. So if we run the `calregionsAG` on a higher number of PCOs, we can appreciate better how `PCOmaxAG` works.

```{r regioncalc_10PCOS}
regionresults.10pcos <- calcregionsAG(Xvar=Xpos, Yvar=PCOscores[,1:10], noregions=nreg, minvert=3, cont=cont, exhaus=F, par=T, numCores=3, verbose=T)
regiondata.10pcos <- regionresults.10pcos$results
PCOmaxAG(regiondata.10pcos, nvert=nvert,cont=cont)
```

It finds that 4 PCOs is the best number of PCOs to include to maximize the region score both if using AICc or BIC to calculate model probability.

The region score with regard to the number of PCOs included can also be plotted using the function `plotpcoregAG`. The orange dots correspond to region scores for cumulated PCOs, purple dots to region scores of each individual PCO, and the grey line corresponds to the cumulated percentage of variance explained by PCOs.

```{r plot.RS-PCO, message=F}
plotpcoregAG(eigenvals=pco.gower$eigen.val, nvert=nvert, regiondata=regiondata.10pcos, cont=cont, title="Test 10 PCOs")
```



 <br>

## 3. Visualizing outputs

### B. Plot vertebral map

The vertebral map (`plotvertmap` function) is a plot where each rectangle correspond to a vertebra and is colored according to the region to which it belongs. The function was coded to incorporate many plotting options (maybe too much?). The basic information to provide is: the `name` of specimen/species (or other) that we plot, the vector with the vertebral positions (`Xvar`), the model to plot, either by providing the `Model_support`object with the `modelsupport` argument or by directly providing a vector with breakpoint position with the argument `BPs`. If the `Model_support` object is provided, the model to plot can be chosen either by its goodness of fit using the `model` argument (1 = best model, 2 = 2^nd^ best, etc.) or by the number of regions it contains using the `model.nreg` argument (1 = 1 region, 2 = 2 regions, etc.). The `plotType` defining how the size and position of each rectangle is calculated must also be provided as either *count*, *percent*, or *length*.


Plotting the best model from the BIC Model_support object:
```{r plot_vertmap, fig.height=1, warning=F}
plotvertmap(name="Dolphin", Xvar=Xpos, modelsupport=support$Model_support_BIC, model=1, plotType="count")


```

Plotting a model by providing a vector of breakpoints:
```{r plot_vertmap2, fig.height=1, warning=F}
plotvertmap(name="Dolphin", Xvar=Xpos, BPs=c(17,25,35), plotType="count")

```


It is also possible to exclude vertebrae not included in the analysis from the plot (in this case cervical vertebrae 1 to 7), with the `drop.na` argument. This is also useful for analyses ran on a subsample of vertebrae:

```{r plot_vertmap3, fig.height=1, warning=F}
plotvertmap(name="Dolphin", Xvar=Xpos, modelsupport=support$Model_support_BIC, model=1, drop.na=T, plotType="count")
```



Plotting a model with X axis as the percentage of total number of vertebrae for the specimen. This can be useful if what to compare two species/specimens with different vertebral count. *Note* that when no model number is specified, the best model will be plotted by default:

```{r plot_vertmap4, fig.height=1, warning=F}
plotvertmap(name="Dolphin", Xvar=Xpos, modelsupport=support$Model_support_BIC, plotType="percent", drop.na=T)
```


If the anteroposterior length of each vertebra is known, it is also possible to plot each vertebra of the vertebral map with its proportional length using the argument `centraL` (which must be provided if *length* is selected as `plotType`).Example here with the centrum length of each vertebra provided as Lc in our original dataset.

```{r plot_vertmap5, fig.height=1, warning=F}
Lc <- dolphin$Lc
plotvertmap(name="Dolphin", Xvar=Xpos, modelsupport=support$Model_support_BIC, plotType="length", centraL=Lc, drop.na=T)
```

We can also add the SD of breakpoint position using the `bp.sd` argument. This can be done with any of the `plotType` options, BPs and SD should always be provided as values corresponding to count (as returned by the `calcBPvar` function), the function then adapts it to correspond to the plotting type . Example by plotting regions following the weighted mean breakpoint position and their weighted SD:

```{r plot_vertmap6, fig.height=1, warning=F}
bps <- unlist(BPvar$WeightedBp["wMean",])
sds <- unlist(BPvar$WeightedBp["wSD",])
plotvertmap(name="Dolphin", Xvar=Xpos, BPs=bps, bp.sd=sds, plotType="count", drop.na=T)


```

It is also possible to show other limits (i.e., anatomical limits) using the `reglimits` argument. For instance, including the limit between the thoracic, lumbar, caudal, and fluke traditional regions of the dolphin (respectively at 17, 25, and 40). By default the plotting color of the limit will be in black, but can be changed with the `lim.col` argument.

```{r plot_vertmap7, fig.height=1, warning=F}
plotvertmap(name="Dolphin", Xvar=Xpos, BPs=bps, bp.sd=sds, plotType="count", drop.na=T, reglimits=c(17,25,40), lim.col="red")
```


The colors of the regions can be changed using the `cols` argument which should be a vector of equal or higher length than the number of regions plotted. Alternatively, it is also possible to force regions in a same predefined "block" to be colored with similar shades using the `col.by.block`, `blocklim`, and `cols` arguments. For instance, coloring regions in the precaudal (i.e., thoracic + lumbar) traditional region in shades of brown, those in the caudal region in shades of blue, and the regions in the fluke in green:

```{r plot_vertmap8, fig.height=1, warning=F}
colsBlock <- list(PreCaudal=c("#BF812D","#8C510A","#543005"),Caudal=c("#C7EAE5","#80CDC1","#35978F","#01665E"), Fluke=c("#236E30","#9CCD9F"))
plotvertmap(name="Dolphin", Xvar=Xpos, BPs=bps, bp.sd=sds, plotType="count", drop.na=T, reglimits=c(17,25,40), lim.col="red", col.by.block=T, cols=colsBlock, blocklim=c(25,40))

```


<br>

## 4. Additional functionalities


**Visualizing output:**

When plotting the segmented regression, the missing vertebrae will automatically be excluded from the graph, but the position of each vertebra included in the analysis is respected.

```{r plot_sub}
plotsegregAG(Xpos_sub, pcono=1, data=scores_sub, modelsupport=support_sub$Model_support_BIC, model=1, cont=T)
```

When plotting the vertebral map, the missing vertebrae can either be included (default) and will appear in grey, or can be excluded with  `drop.na=T`.

```{r plot_sub2, fig.height=1, warning=F}
# Missing vertebrae included:
plotvertmap(name="Dolphin_sub", Xvar=Xpos_sub, modelsupport=support_sub$Model_support_BIC, model=1, plotType="percent", drop.na=F)
```
```{r plot_sub3, fig.height=1, warning=F}
# Missing vertebrae excluded:
plotvertmap(name="Dolphin_sub", Xvar=Xpos_sub, modelsupport=support_sub$Model_support_BIC, model=1, plotType="percent", drop.na=T)
```

